"""CLI for JDC utilities"""

import click
from jdc_utils.submission import build_resource, create_resource_validation_report
from jdc_utils.transforms import read_df, run_transformfile
import jdc_utils.dataforge_ids as ids
import jdc_utils.dataforge_tools as tools
from jdc_utils.utils import copy_file
import os
import pandas as pd
import glob 
from pathlib import Path 
import yaml
import sys 

# overall CLI
@click.group()
def cli():
    """CLI for JDC utilities"""
    pass

@click.command(help=''' 


This function is used to replace (and map) local ids assigned at the time of data collection
with separate ids generated by the DASC and given to hubs.

Replacing local ids with JDC specific ideas reduces the risk of hub and participant identification.

The mapped local to JDC ids are intended to be seen only by hub staff. 

IN DEVELOPMENT: Additionally, this function accepts remote version control history (ie git repo) to save previous versions.
'''
)
@click.option(
    "--file-path",
    "file_paths",
    help="Path to a file with locals/old ids to be replaced. Can specify multiple files if need to replace ids across multiple files",
    multiple=True,
    #required=True,
)
@click.option(
    "--id-file",
    help="Path to where the generated ids (created by the MAARC and distributed to hubs) exist",
    #required=True,
)
@click.option(
    "--map-file",
    help="Path to csv where the id mappings are stored -- this will be generated if file does not exist",
    default=None
)
@click.option("--map-url", help='Git bare repo set up -- ie the "remote url" for sharing mapped ids', default=None)
@click.option("--column", help="Name of column across files specified with old (or local) ids. \
    If none specified, defaults to first level (ie 0) pandas dataframe index", default=None)
@click.option("--config-file", help="A configuration file containing all required replace-id fields", default=None)

#TODO: add other possible params
def replace_ids(file_paths, id_file, map_file,map_url,column,config_file=None):
    replace_ids_dir = os.path.join("tmp", "jdc",'replaced_ids')
    os.makedirs(replace_ids_dir, exist_ok=True)

    #if no config file, then need these params
    if not config_file:
        assert map_file
        assert id_file
        assert file_paths
    for file_path in file_paths:
        #glob.glob allows support for both wildcards (*) and actual file paths
        file_path_with_glob_regexs = glob.glob(file_path) #if not a regex, will just return the filepath within list
        for file_path_glob in file_path_with_glob_regexs:
            df = read_df(file_path_glob)

            if config_file:
                with open(config_file,'r') as f:
                    config = yaml.safe_load(f)
                replace_id_params = config['replace_ids']
                df_new = ids.replace_ids(df, **replace_id_params)
            else:
                df_new = ids.replace_ids(
                    df, id_file=id_file, map_file=map_file, map_url=map_url, column=column
                )

            file_name = Path(file_path_glob).stem
            new_file_dir = os.path.join(replace_ids_dir, file_name+'.csv')
            df_new.to_csv(new_file_dir,index=False)
            click.echo(f"Replaced local with jdc ids in: {os.path.join(os.getcwd(),new_file_dir)}")

@click.command(help=''' 
This function takes a specified date field and shifts them around a specified number of days (ie shift amount).
This shifted amount is selected randomly within an interval of the previous 182 days and next 182 days.
This shift amount is fixed within each individual such that the intervals between dates are retained to provide the 
capability to calculate derived variables such as days from a given visit/timepoint (e.g., days from baseline or 
days from release). 

As with the replace id function, the mappings (i.e., id to the random # of days shifted) is stored in a separate file
to reduce deductive disclosure risk from PII linkage with date variables.

However, by storing this shift amount (rather than randomly shifting at each data update, 
the exact dates can be recovered
simply by subtracting this added random amount to the shifted date.

IN DEVELOPMENT: Additionally, this function accepts remote version control history (ie git repo) to save previous versions.
'''
)
@click.option(
    "--file-path",
    "file_paths",
    help="Path to a file with dates to be shifted. Can specify multiple files if column name is the same across files",
    multiple=True,
    #required=True,
)
@click.option(
    "--map-file",
    help="path to csv where the id mappings are stored -- this will be generated if file does not exist",
    default=None
)
@click.option("--map-url", help='Git bare repo set up -- ie the "remote url" for sharing mapped ids (optional)', default=None)
@click.option("--id-column", help="Name of column across files specified ids.", default=None)
@click.option("--date-column", help="Name of date column(s) to be shifted", default=None,multiple=True)
@click.option("--config-file", help="A configuration file containing all required shift date fields", default=None)

def shift_dates(file_paths,map_file,map_url,id_column,date_column,config_file):
    shifted_dates_dir = os.path.join("tmp", "jdc",'shifted_dates')
    os.makedirs(shifted_dates_dir, exist_ok=True)

    #if no config file, then need these params
    if not config_file:
        assert map_file
        assert file_paths
        assert date_column
    for file_path in file_paths:
        #glob.glob allows support for both wildcards (*) and actual file paths
        file_path_with_glob_regexs = glob.glob(file_path) #if not a regex, will just return the filepath within list
        for file_path_glob in file_path_with_glob_regexs:
            df = read_df(file_path_glob)

            if config_file:
                with open(config_file,'r') as f:
                    config = yaml.safe_load(f)
                params = config['shift_dates']
                df_new = tools.shift_dates(df, **params)
            else:
                df_new = tools.shift_dates(
                    df, 
                     map_file=map_file,
                      map_url=map_url, 
                      id_col=id_column,
                      date_cols=date_column
                )

            file_name = Path(file_path_glob).stem
            new_file_dir = os.path.join(shifted_dates_dir, file_name+'.csv')
            df_new.to_csv(new_file_dir,index=False)
            click.echo(f"Shifting dates and saving to: {os.path.join(os.getcwd(),new_file_dir)}")


@click.command(
    ''' 
    This input file transforms a given dataset with a variety of functions or any function 
    available within pandas that has an "inplace" argument. 

    Most commonly, this will entail renaming variables and values to match the data model
    schema in order to pass validation (see the jdc-utils validate function)

    ''' 
)
@click.option("--transform-file", help="Path to the given transform file")
@click.option("--file-path", help="Path to the given dataset file")
def transform(transform_file, file_path):

    # read in and run transforms -- right now currently using pandas -- may want to migrate to petl
    # for consistency with validation as it uses petl to read in and type conversions may be different.
    # alternatively, we could use the pandas plugin for frictionless but it is experimental.
    df = read_df(file_path)
    run_transformfile(df, transform_file)

    # make transform dir
    transform_dir = os.path.join("tmp","jdc","transformed")
    os.makedirs(transform_dir, exist_ok=True)

    # save file
    file_name = os.path.split(file_path)[-1]
    file_path_to_save = os.path.join(transform_dir, file_name)
    df.to_csv(file_path_to_save)
    click.echo(f"Transformed file saved to {file_path_to_save}")


@click.command()
@click.option(
    "--schema-path", help="Frictionless table schema JSON or YAML file path",default=None
)  # make this either a path or a option of baseline/followup
@click.option(
    "--file-path",
    help="Path to dataset file(s)",
    multiple=True,
)
@click.option(
    "--file-type",
    type=click.Choice(['baseline', 'time-points']),
    help="Type of file(s). Currently either baseline or time-points"
)
def validate(schema_path, file_path,file_type):

    #get the directory of package and then add join with where the table schemas live
    schemas_dir = os.path.join(os.path.dirname(__file__), 'frictionless','table_schemas')
    
    if file_type:
        with open(os.path.join(schemas_dir,'table_schema_urls.yaml')) as f: 
            schema_path = yaml.safe_load(f)[file_type]
    
    if not schema_path:
        sys.exit(
            "Need to select the type of file(s) you are validating. For more info on options, run:\n"
            "jdc-utils validate --help"
        )
    file_path = [f for f in file_path if f]  # get rid of ""
    resource = build_resource(schema_path, file_path)
    report = create_resource_validation_report(resource)

    validated_dir = os.path.join("tmp","jdc", "frictionless")
    os.makedirs(validated_dir, exist_ok=True)

    if report["is_valid"]:
        click.echo(
            f"Congrats! Your file(s) -- {report['file_names']} ---  passed validation!\n"
            f"Now saving to {validated_dir}"
        )
        click.echo("If you're happy with them, you can proceed with submission.")
        # save to file
        for f in file_path:
            validated_file_path = os.path.join(validated_dir, os.path.split(f)[-1])
            copy_file(f, validated_file_path)
    else:
        click.echo(
            "\n\n"
            f"{report['file_names']}: invalid.\n"
            f"Take a look below at the error report table below to correct.\n"
            f"We'll also save your errors to the {validated_dir}\errors.tsv file\n"
            "----------------------------------------------------------------------\n"
            "----------------------------------------------------------------------\n"
        )
        report['errors_df'].replace('"','',inplace=True)
        click.echo(report['errors_df'][['error-category','error-message',]].to_string(index=False))
        # append error.tsv
        report['errors_df'].to_csv(os.path.join(validated_dir,"errors.tsv"),sep="\t")

cli.add_command(replace_ids, name="replace-ids")
cli.add_command(shift_dates, name="shift-dates")
cli.add_command(transform, name="transform")
cli.add_command(validate, name="validate")


if __name__ == "__main__":
    cli()
